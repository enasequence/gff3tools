- Feature Name: (fill me in with the feature name, `my_awesome_feature_design`)
- Document Date: (fill me in with today's date, YYYY-MM-DD)
- Last Updated: (fill me in with the last update date, YYYY-MM-DD)

# Summary

One paragraph explanation of the implemented feature or system. What does it do?

# Motivation & Rationale

Explain the problem this feature/system was designed to solve. Why was it built? What specific use cases does it address?
Detail the rationale behind the chosen design. Why was this particular approach taken over others? What were the key considerations and trade-offs? This section should clearly articulate the "why" behind the implementation.

# Usage Guidelines

Explain how to use or interact with the implemented feature/system. This could include:
- How to configure it.
- How to extend it (e.g., adding new components, subclasses, or rules).
- Best practices for common use cases.
- Any specific conventions or patterns to follow.

# System Overview / High-Level Design

Explain the feature/system at a high level, as if you were explaining it to another developer who needs to understand its core components and how they interact.
- Introduce new named concepts or modules.
- Describe the main components and their responsibilities.
- Include architectural diagrams (e.g., block diagrams, data flow diagrams) or describe where such diagrams can be found (e.g., link to an external Lucidchart/Excalidraw diagram).
- Explain how this feature integrates with existing parts of the system.

# Detailed Design & Implementation

This is the technical portion of the document, explaining the actual implementation details.
- Describe the key classes, functions, or services involved.
- Explain important algorithms or data structures used.
- Detail significant implementation decisions, including specific libraries or technologies chosen and why.
- Discuss how specific corner cases or error conditions are handled.
- If applicable, provide code snippets or links to key code sections that illustrate complex logic.
- Explain how the design addresses the examples or use cases from the "Motivation & Rationale" section.


# Alternatives Considered

Briefly describe other significant design approaches that were considered during the RFC or design phase, and explain why they were not chosen. What were their drawbacks compared to the chosen solution?

# Technical Debt / Future Considerations

- What known limitations or technical debt exist within this implementation?
- What are the potential future extensions or improvements for this feature/system?
- Are there any related issues or features that are out of scope for the current implementation but might be addressed later?

# Testing Strategy

Describe how this feature/system is tested.
- What types of tests are in place (unit, integration, end-to-end)?
- Are there any specific testing frameworks or methodologies used?
- How can a developer verify the correct functioning of this feature?

# Deployment & Operations

- How is this feature/system deployed?
- Are there any specific operational considerations (e.g., monitoring, logging, scaling)?
- What are the dependencies for deployment?

# Related Documentation & Resources

- Links to the original RFC (if applicable).
- Links to relevant code repositories or directories.
- Links to external libraries, APIs, or documentation that are critical for understanding this feature.
- Links to monitoring dashboards, alerts, or runbooks related to this feature.

